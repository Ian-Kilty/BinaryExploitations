https://github.com/LiveOverflow/liveoverflow_youtube/tree/master/0x05_simple_crackme_intro_assembler

Find license_1.c

Look at the binary assembler use a program called gdb (GNU de-bugger) - https://www.gnu.org/software/gdb/documentation/
    gdb <path to binary>
    gdb license_1

Every C program has a main function so disassemble main displays all the assembly code from the main function
    disassemble main
    disassemble <function> - by default that will give you the att syntax and we need intel
    
    set disassembly-flavor intel - remember tab completion and this sets the syntax to intel

Ignore most of the stuff and focus on the flow of things

Here is the code 
    (gdb) disassemble main
    Dump of assembler code for function main:
        0x0000000000001189 <+0>:	endbr64 
        0x000000000000118d <+4>:	push   rbp
        0x000000000000118e <+5>:	mov    rbp,rsp
        0x0000000000001191 <+8>:	sub    rsp,0x10
        0x0000000000001195 <+12>:	mov    DWORD PTR [rbp-0x4],edi
        0x0000000000001198 <+15>:	mov    QWORD PTR [rbp-0x10],rsi
        0x000000000000119c <+19>:	cmp    DWORD PTR [rbp-0x4],0x2 - compare with the number 2
        0x00000000000011a0 <+23>:	jne    0x11fb <main+114> - Jump not equal so something checks if its 2 and jumps to the printf statment
        0x00000000000011a2 <+25>:	mov    rax,QWORD PTR [rbp-0x10]
        0x00000000000011a6 <+29>:	add    rax,0x8
        0x00000000000011aa <+33>:	mov    rax,QWORD PTR [rax]
        0x00000000000011ad <+36>:	mov    rsi,rax
        0x00000000000011b0 <+39>:	lea    rdi,[rip+0xe4d]        # 0x2004
        0x00000000000011b7 <+46>:	mov    eax,0x0
        0x00000000000011bc <+51>:	call   0x1080 <printf@plt> - printf for displaying text
        0x00000000000011c1 <+56>:	mov    rax,QWORD PTR [rbp-0x10]
        0x00000000000011c5 <+60>:	add    rax,0x8
        0x00000000000011c9 <+64>:	mov    rax,QWORD PTR [rax]
        0x00000000000011cc <+67>:	lea    rsi,[rip+0xe47]        # 0x201a
        0x00000000000011d3 <+74>:	mov    rdi,rax
        0x00000000000011d6 <+77>:	call   0x1090 <strcmp@plt> - string compare (man 3 strcmp) returns 0 if they are the same
        0x00000000000011db <+82>:	test   eax,eax
        0x00000000000011dd <+84>:	jne    0x11ed <main+100> - if the zero_flag is not set from strcmp there will be a put call
        0x00000000000011df <+86>:	lea    rdi,[rip+0xe44]        # 0x202a
        0x00000000000011e6 <+93>:	call   0x1070 <puts@plt>
        0x00000000000011eb <+98>:	jmp    0x1207 <main+126>
        0x00000000000011ed <+100>:	lea    rdi,[rip+0xe46]        # 0x203a
        0x00000000000011f4 <+107>:	call   0x1070 <puts@plt> - the put call from the not set zero_flag jne that prints text (man 3 puts)
        0x00000000000011f9 <+112>:	jmp    0x1207 <main+126>
        0x00000000000011fb <+114>:	lea    rdi,[rip+0xe3f]        # 0x2041
        0x0000000000001202 <+121>:	call   0x1070 <puts@plt>
        0x0000000000001207 <+126>:	mov    eax,0x0
        0x000000000000120c <+131>:	leave  
        0x000000000000120d <+132>:	ret    
    End of assembler dump.

Execute step by step and see which path you have taken

Add a break point at the start of main
    break *main - sets breakpoint
    run - runs program

gdb will execute until it hits the breakpoint and then it will stop

Look at the registers with 
    info registers

Look for the rip (Instruction pointer) which is pointing to the first address in main
    rip            0x555555555189      0x555555555189 <main>

Then use si to step one instruction
    si - this executes one machine instruction then returns to the debugger

    info registers - rip            0x55555555518d      0x55555555518d <main+4>

Now going through the program you will need to use ni instead of si because si steps into functions and ni dosen't
And when you just press enter it repeats the previous command

    (gdb) ni
    0x000055555555518e in main ()
    (gdb) 
    0x0000555555555191 in main ()
    (gdb) 
    0x0000555555555195 in main ()
    (gdb) 
    0x0000555555555198 in main ()
    (gdb) 
    0x000055555555519c in main () 
    (gdb) 
    0x00005555555551a0 in main () - we can see that we jumped here so what ever that was compared to 2 wasn't 2
    (gdb) 
    0x00005555555551fb in main ()
    (gdb) 
    0x0000555555555202 in main ()
    (gdb) 
    Usage: <key> - printed the usage in the last put call and we didn't run with a key so lets do that
    0x0000555555555207 in main ()
    0x0000555555555207 in main ()
    (gdb) 
    0x000055555555520c in main ()
    (gdb) 
    0x000055555555520d in main ()
    (gdb) 
    __libc_start_main (main=0x555555555189 <main>, argc=1, 
        argv=0x7fffffffdef8, init=<optimized out>, fini=<optimized out>, 
        rtld_fini=<optimized out>, stack_end=0x7fffffffdee8)
        at ../csu/libc-start.c:342
    342	../csu/libc-start.c: No such file or directory.

Running program with a key
    run AAAA-KEY-1234

    (gdb) ni
    0x000055555555518d in main ()
    (gdb) 
    0x000055555555518e in main ()
    (gdb) 
    0x0000555555555191 in main ()
    (gdb) 
    0x0000555555555195 in main ()
    (gdb) 
    0x0000555555555198 in main ()
    (gdb) 
    0x000055555555519c in main ()
    (gdb) 
    0x00005555555551a0 in main () - we do not jump this time because there is a key provided
    (gdb) 
    0x00005555555551a2 in main ()
    (gdb) 
    0x00005555555551a6 in main ()
    (gdb) 
    0x00005555555551aa in main ()
    (gdb) 
    0x00005555555551ad in main ()
    (gdb) 
    0x00005555555551b0 in main ()
    (gdb) 
    0x00005555555551b7 in main ()
    (gdb) 
    0x00005555555551bc in main ()
    (gdb) 
    Checking License: AAAA-KEY-1234 - Checks key and printf
    0x00005555555551c1 in main ()
    (gdb) 
    0x00005555555551c5 in main ()
    (gdb) 
    0x00005555555551c9 in main ()
    (gdb) 
    0x00005555555551cc in main ()
    (gdb) 
    0x00005555555551d3 in main ()
    (gdb) 
    0x00005555555551d6 in main ()
    (gdb) 
    0x00005555555551db in main ()
    (gdb) 
    0x00005555555551dd in main () - it jumped so that means that the strcmp failed 
    (gdb) 
    0x00005555555551ed in main ()
    (gdb) 
    0x00005555555551f4 in main ()
    (gdb) 
    WRONG! - printf
    0x00005555555551f9 in main ()
    (gdb) 
    0x0000555555555207 in main ()
    (gdb) 
    0x000055555555520c in main ()
    (gdb) 
    0x000055555555520d in main ()
    (gdb) 
    __libc_start_main (main=0x555555555189 <main>, argc=2, 
        argv=0x7fffffffdee8, init=<optimized out>, fini=<optimized out>, 
        rtld_fini=<optimized out>, stack_end=0x7fffffffded8)
        at ../csu/libc-start.c:342
    342	../csu/libc-start.c: No such file or directory.

Now we want to set a breakpoint before the last strcmp and run the program 
    disassemble *main
    break *0x00005555555551db

           0x00005555555551d6 <+77>:	call   0x555555555090 <strcmp@plt>
           0x00005555555551db <+82>:	test   eax,eax
           0x00005555555551dd <+84>:	jne    0x5555555551ed <main+100>
        
    run AAAA-KEY-1234
    continue - this will run the program normally until we hit the next breakpoint




