This website is very useful to understand assembly just go down to assembly programming

https://sockpuppet.org/issue-79-file-0xb-foxport-hht-hacking.txt.html

The lines in assembly are not numbers but memory addresses like 0x4005db
You have 8-32 global vars that we can use called registers

Some registers are more important such as the program counter which tells the program which instructions to execute next
Everytime an instruction is executed, the program counter advances
This register is often called the PC (program counter) but on some processors it is called the instruction pointer (IP, EIP, RIP)

The RIP will have the line of the instruction that is to be executed next, often refered to as pointing to a line
It will always increase by 1 to move to the next line if other instructions are not specified

Examples of assembly code
    mov eax, 0x5 - eax is a register that is assigned the number 5
    add eax, 0x3 - eax is currently 5 but then adds 3 to it
    mov ebx, 0x8
    sub eax, ebx - ebx is subtracted from eax giving 0

What dosen't fit in the registers is in the memory which means that you can use different parts of the assembly file to store values
This memory is accessed in two methods
    With loads and stores like all the memory is a big array
    Through PUSH and POP operations on a stack

The load and stores are called mov in x86 assembler so you can move a value from a register to memory and vice versa
So you can treat the file like an array
    mov eax, [14] - this assigns eax the value specified on line 14 of the file

The stack is an area at the bottom of the file and you have special registers like the RIP that point to the top of the stack (SP, ESP, RSP)
Push a new value to the top of the stack
    push 0x5 - the RSP will be incrimented because the stack is upside down and grows from the bottom
    pop eax - the value at the address of the stack pointer will be assigned to eax and the stack pointer will be decremented

In assebmly, you store variables in memory and then do things with them then put them back

Control flow is done by changing the Instruction Pointer (RIP) through things called GOTOs that are either jumps, branches, or calls
    jmp 5 - changes the instruction pointer to value 5 - jump is always unconditional

Just like many programming languages like C, when a function or program exits with a status code of 0 it means that there were no errors
These are called status flags in assembly
    zero_flag = null
    mov eax, 0x5 
    add eax, 0x3 - the result is greater than 0 so the zero_flag is not set or simply 0
    mov ebx, 0x8
    sub eax, ebx - the result is 0 so the zero_flag is set to 1

There can be contitional GOTOs that depend on the zero_flag or other vars
    je 5 - (x86) stands for jump equals and in this case if the zero_flag is 0 only then will it jump to line 5


